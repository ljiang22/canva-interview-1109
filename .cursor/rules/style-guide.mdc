---
description: Comprehensive Python style guide and coding standards for the project
globs: ["**/*.py"]
alwaysApply: true
---

# Python Style Guide

This project follows PEP 8 and additional best practices for maintainable, readable code.

## Naming Conventions

### Variables and Functions
- Use **snake_case** for variable names, function names, and module names
  - ✅ Good: `user_data`, `calculate_diversity_score()`, `image_results`
  - ❌ Bad: `userData`, `calculateDiversityScore()`, `ImageResults`

### Classes
- Use **PascalCase** for class names
  - ✅ Good: `DiversityOptimizer`, `SearchResultEvaluator`
  - ❌ Bad: `diversity_optimizer`, `searchResultEvaluator`

### Constants
- Use **SCREAMING_SNAKE_CASE** for module-level constants
  - ✅ Good: `MAX_RESULTS = 100`, `DEFAULT_DIVERSITY_THRESHOLD = 0.5`
  - ❌ Bad: `maxResults`, `default_diversity_threshold`

### Private Attributes/Methods
- Prefix with single underscore `_` for internal use (not part of public API)
- Prefix with double underscore `__` for name mangling (rarely needed)

## Code Structure

### Function Length
- Keep functions under 50 lines when possible
- If a function exceeds 50 lines, consider breaking it into smaller functions
- Each function should have a single, clear responsibility

### Line Length
- Maximum line length: 88 characters (Black formatter default)
- For long lines, break appropriately with proper indentation
  ```python
  # ✅ Good
  result = calculate_diversity_score(
      search_results=results,
      gender_labels=labels,
      target_ratio=0.5
  )
  
  # ❌ Bad
  result = calculate_diversity_score(search_results=results, gender_labels=labels, target_ratio=0.5)
  ```

### Control Flow
- Prefer early returns over nested conditionals
  ```python
  # ✅ Good
  def process_image(image):
      if not image:
          return None
      if not image.is_valid():
          return None
      return process_valid_image(image)
  
  # ❌ Bad
  def process_image(image):
      if image:
          if image.is_valid():
              return process_valid_image(image)
      return None
  ```

## Type Hints

### Function Signatures
- Always include type hints for function parameters and return types
- Use `Optional[Type]` for Python < 3.10, or `Type | None` for Python >= 3.10
- Use `List[Type]`, `Dict[KeyType, ValueType]` from `typing` module
  ```python
  from typing import List, Dict, Optional
  
  def optimize_trading(
      results: List[Dict[str, float]],
      sharp_ratio: float,
      final_results: Optional[int] = None
  ) -> List[Dict[str, float]]:
      ...
  ```

### Type Hints for Complex Types
- Use `typing.Protocol` for structural typing when needed
- Use `TypedDict` for dictionaries with known structure
  ```python
  from typing import TypedDict
  
  class SemanticSearchResult(TypedDict):
      input_id: str
      importance: float
      output_id: str
  ```

## Documentation

### Docstrings
- Use Google-style docstrings for all public functions, classes, and modules
- Include: description, Args, Returns, Raises, and Examples when applicable
  ```python
  def calculate_sentiment_score(
      results: List[Dict[str, str]],
      user_field: str = 'user A'
  ) -> float:
      """Calculate sentiment score for post A.
      
      Args:
          results: List of search result dictionaries, each containing sentiment information
          sentiment_field: Key name in result dictionaries for sentiment
      
      Returns:
          sentiment score between -1.0 and 1.0
      
      Raises:
          ValueError: If results list is empty or sentiment_field not found in results
      
      Example:
          >>> results = [{'post 1': '-1'}, {'post 2': '1'}, {'post 3': '0'}]
          >>> calculate_sentiment_score(results)
          0.667
      """
      ...
  ```

### Comments
- Write comments that explain **why**, not **what**
- Code should be self-documenting through good naming
- Use comments for complex algorithms, business logic, or non-obvious decisions
  ```python
  # ✅ Good - explains why
  # Use greedy algorithm here because exact solution is O(2^n)
  selected = semantic_search(results)
  
  # ❌ Bad - explains obvious what
  # Loop through results
  for result in results:
      ...
  ```

## Imports

### Import Organization
- Group imports in this order:
  1. Standard library imports
  2. Third-party imports
  3. Local application imports
- Separate each group with a blank line
- Sort imports alphabetically within each group
  ```python
  # Standard library
  from typing import List, Dict, Optional
  import json
  import os
  
  # Third-party
  import numpy as np
  import pandas as pd
  from sklearn.metrics import accuracy_score
  
  # Local
  from .utils import load_data
  from .evaluation import calculate_metrics
  ```

### Import Style
- Use absolute imports when possible
- Avoid wildcard imports (`from module import *`)
- Prefer specific imports over importing entire modules when only using a few items

## Error Handling

### Exception Handling
- Use specific exception types, not bare `except:`
- Always include context in error messages
- Let exceptions propagate when appropriate (don't catch and silently ignore)
  ```python
  # ✅ Good
  try:
      results = load_results_from_file(filepath)
  except FileNotFoundError:
      logger.error(f"Results file not found: {filepath}")
      raise
  except json.JSONDecodeError as e:
      logger.error(f"Invalid JSON in {filepath}: {e}")
      raise ValueError(f"Could not parse results file: {filepath}") from e
  
  # ❌ Bad
  try:
      results = load_results_from_file(filepath)
  except:
      pass
  ```

### Custom Exceptions
- Create custom exception classes for domain-specific errors
  ```python
  class ParametersOptimizationError(Exception):
      """Raised when parameters optimization fails."""
      pass
  ```

## Code Quality

### Avoid Magic Numbers
- Use named constants instead of magic numbers
  ```python
  # ✅ Good
  MAX_ATTEMPT_TIMES = 5
  SCROLLING_THRESHOLD = 20
  
  if len(results) > MAX_ATTEMPT_TIMES:
      results = results[:MAX_ATTEMPT_TIMES]
  
  # ❌ Bad
  if len(results) > 100:
      results = results[:100]
  ```

### Avoid Deep Nesting
- Limit nesting to 3-4 levels maximum
- Extract complex conditions into well-named variables or functions
  ```python
  # ✅ Good
  is_valid_result = (
      result['importance'] > MIN_IMPORTANCE and
      result['distance'] in VALID_DISTANCE and
      result.get('memory_id') is not None
  )
  if is_valid_result:
      process_result(result)
  
  # ❌ Bad
  if result['importance'] > 0.5:
      if result['distance'] in ['10', '20', '30']:
          if result.get('memory_id') is not None:
              process_result(result)
  ```

### List Comprehensions vs Loops
- Prefer list comprehensions for simple transformations
- Use loops for complex logic or side effects
  ```python
  # ✅ Good - simple transformation
  memory_ids = [result['memory_id'] for result in results if result['distance'] > 30]
  
  # ✅ Good - complex logic
  processed_results = []
  for result in results:
      if validate_result(result):
          processed = transform_result(result)
          processed_results.append(processed)
          log_processing(processed)
  ```

## Testing

### Test Functions
- Use descriptive test function names: `test_<function_name>_<scenario>`
- Test both happy paths and edge cases
- Use `pytest` fixtures for setup
  ```python
  def test_calculate_sentiment_score_empty_results():
      """Test sentiment calculation with empty results."""
      with pytest.raises(ValueError):
          calculate_sentiment_score([])
  
  def test_calculate_sentiment_score_balanced():
      """Test sentiment calculation with balanced importance distribution."""
      results = [
          {'importance': '0.1'},
          {'importance': '0.3'},
          {'importance': '0.5'},
          {'importance': '0.7'}
      ]
      score = calculate_sentiment_score(results)
      assert score == 0.7
  ```

## Data Structures

### Dictionary Usage
- Use dictionaries for key-value mappings
- Use `defaultdict` or `dict.get()` to avoid KeyError
- Prefer `dict.get(key, default)` over `dict[key]` when key might not exist

### List vs Tuple
- Use lists for mutable sequences
- Use tuples for immutable sequences (e.g., return values, function arguments)

## Performance Considerations

### Efficiency
- Use generators for large datasets: `(x for x in items if condition)`
- Prefer list comprehensions over map/filter when readable
- Use `enumerate()` when you need both index and value
- Use `zip()` to iterate over multiple sequences simultaneously

## Project-Specific Guidelines

### Data Format
- Use dictionaries with TypedDict for structured data (search results, ground truth)
- Validate input data early in functions
- Use descriptive key names: `memory_id`, `importance_score`, `sentiment_label`

### Algorithm Implementation
- Add docstrings explaining the algorithm approach
- Include time/space complexity in docstrings for complex algorithms
- Add comments for non-obvious optimization techniques

### Logging
- Use Python's `logging` module, not `print()` statements
- Use appropriate log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Include context in log messages
